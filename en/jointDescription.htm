<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Strict//EN">
<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<title>Joint types and operation</title>
<link rel="stylesheet" type="text/css" href="../style.css">
</head>

<body>

<div align="center">
<table class=allEncompassingTable >
 <tr>
  <td >
<p><a href="../index.html" TARGET="_top"><img src="images/homeImg.png"></a></p>



<h1>Joint types and operation</h1>


<p>A joint is used to allow for a relative movement between its parent and its children. When a parent-child relationship is built between a joint and an object, the object is attached to the joint's second reference frame, thus, a change of the joint's configuration (intrinsic position) will directly be reflected onto its children. New joints can be added to a <a href="scenes.htm">scene</a> with [Menu bar --&gt; Add --&gt; Joints].
</p>


<br>
<h2>
<a name="types"></a>Joint types
</h2>

<p>4 types of joints are supported:</p>

<p align=center><img src="images/jointDescription1.jpg"></p>
<p class=imageLabel>[Revolute joint, prismatic joint, screw and spherical joint]</p>
<br>

<li><strong>Revolute joints</strong>: revolute joints have one DoF and are used to describe rotational movements (with 1 DoF) between objects. Their configuration is defined by one value that represents the amount of rotation about their first reference frame's z-axis<br>
</li>

<li><strong>Prismatic joints</strong>: prismatic joints have one DoF and are used to describe translational movements between objects. Their configuration is defined by one value that represents the amount of translation along their first reference frame's z-axis<br>
</li>

<li><strong>Screws</strong>: screws, which can be seen as a combination of revolute joints and prismatic joints (with linked values), have one DoF and are used to describe a movement similar to a screw. A pitch parameter defines the amount of translation for a given amount of rotation. A screw configuration is defined by one value that represents the amount of rotation about its first reference frame's z-axis<br>
</li>

<li><strong>Spherical joints</strong>: spherical joints have three DoF and are used to describe rotational movements (with 3 DoF) between objects. In some situations, a spherical joint can be thought of as 3 concurrent and orthogonal to each other joints, that are parented in a hierarchy-chain. The analogy is however only valid while all revolute joints keep an orientation distinct from any of the two others: indeed, should two joints come close to coincide, a singular situation might appear and the mechanism might lose one DoF. This does never happen with spherical joints that are internally handled to avoid this kind of situation </li>

<p align=center><img src="images/jointDescription2.jpg"></p>
<p class=imageLabel>[Two equivalent mechanisms (in this configuration): spherical joint (left) and 3 revolute joints (right)]</p>
<br>


<p align=center><img src="images/jointDescription3.jpg"></p>
<p class=imageLabel>[Two non-equivalent mechanisms: the right configuration is close to a singularity]</p>
<br>

<br>
<h2>
<a name="modes"></a>Joint modes
</h2>

<p>A joint can be in one of following modes:
</p>

<li><strong>Kinematic mode</strong>: in this mode the joint is not directly controlled and will act as a fixed link. The user can however change the joint's position with appropriate <a href="apisOverview.htm">API</a> function calls (e.g. <a href="regularApi/simSetJointPosition.htm">sim.setJointPositon</a> or <a href="regularApi/simSetObjectChildPose.htm">sim.setObjectChildPose</a>).<br>
</li>

<li><strong>Dependent mode</strong>: in this mode, the joint position is directly linked (dependent) to another joint position through a linear equation.<br>
</li>

<li><strong>Dynamic mode</strong>: in this mode, the joint is handled by the <a href="dynamicsModule.htm">dynamics module</a>, if it forms with its connecting items a valid configuration. When dynamically enabled, a joint can be free or controlled in force/torque, in velocity or in position. 
</li>

<li class=tabTab>When the joint motor is disabled, the joint is free and only constrained by its limits.
</li>

<li class=tabTab>When the joint motor is enabled and the control loop is disabled, then the joint will try to reach the desired target velocity given the maximum torque/force it is capable to deliver. When that maximum torque/force is very high, the target velocity is instantaneously reached and the joint operates in velocity control, otherwise it operates at the specified torque/force until the desired target velocity is reached (torque/force control).
</li>

<li class=tabTab>When the joint motor is enabled and the control loop is enabled, then the user has 3 control modes available:</li>

<li class=fourTabs><em>Custom control</em>: a <a href="jointCallbackFunctions.htm">joint callback function</a> will be in charge of controlling the dynamic behaviour of the joint, allowing to control the joint with any desired algorithm. </li>


<li class=fourTabs><em>Position control (PID)</em>: the joint will be controlled in position via a PID controller that will adjust the joint velocity in following way (the <em>&#916;t</em> divider is to keep the controller independent of the selected controller time step): </li>

<p align=center><img src="images/jointDescription5.jpg"></p>
<br>


<li class=fourTabs><em>Spring-damper mode</em>: the joint will act like a spring-damper system via a force/torque modulation: </li>

<p align=center><img src="images/jointDescription6.jpg"></p>
<br>


<br>
<h2>
<a name="controller"></a>Joint controllers
</h2>

<p>There are many different ways a joint can be controlled. In following section, we differentiate betwen a <em><strong>loose</strong></em> controller and a <em><strong>precise</strong></em> controller: a <em><strong>loose</strong></em> joint controller will not be able to provide new control values in each possible regulation step (e.g. some regulation steps might/will be skipped, but control is still possible). A <em><strong>precise</strong></em> joint controller on the other hand, will be able to provide control values in each possible regulation step.</p>

<p>First, the approach to take for controlling a joint will depend on the joint mode:</p>

<li><a href="#kinematic">The joint is in kinematic mode</a></li>
<li><a href="#dynamic">The joint is in dynamic mode</a></li>

<p><strong><a name="nonForceTorqueMode"></a><a name="kinematic"></a>The joint is in kinematic mode</strong>: in this situation, the joint can directly (and instantaneously) be controlled, i.e. set it to a desired position via <a href="regularApi/simSetJointPosition.htm">sim.setJointPosition</a>. This can be done from a <a href="childScripts.htm">child script</a>, from a <a href="plugins.htm">plugin</a>, from a <a href="rosInterfaces.htm">ROS</a> node, or from a <a href="remoteApiOverview.htm">remote API</a> client. If done from a child script, then it should be done inside of the <em>actuation section</em> of the <a href="childScripts.htm">child script</a>.</p>

<p>In following threaded <a href="childScripts.htm">child script</a> example, the joint is controlled <em><strong>loosely</strong></em>  in position, and there is no synchronization with the simulation loop:</p>

<code class="hljs language-lua coppelia-coppeliasim-script">
-- Following script should run threaded:

jointHandle=sim.getObject('/Revolute_joint')

sim.setJointPosition(jointHandle,90*math.pi/180) -- set the position to 90 degrees
sim.wait(2) -- wait 2 seconds (in simulation time)
sim.setJointPosition(jointHandle,180*math.pi/180) -- set the position to 180 degrees
sim.wait(1) -- wait 1 second (in simulation time)
sim.setJointPosition(jointHandle,0*math.pi/180) -- set the position to 0 degrees
etc.</code>

<p>In following threaded <a href="childScripts.htm">child script</a> example, the joint is controlled <strong>precisely</strong> in position in each simulation step, i.e. the thread is synchronized with the simulation loop:</p>

<code class="hljs language-lua coppelia-coppeliasim-script">
-- Following script should run threaded:

local initialForbidLevel=sim.setThreadAutomaticSwitch(false) -- Automatic thread switching disabled
jointHandle=sim.getObject('/Revolute_joint')

sim.setJointPosition(jointHandle,90*math.pi/180) -- set the position to 90 degrees
sim.switchThread() -- the thread resumes in next simulation step (i.e. when t becomes t+dt)
sim.setJointPosition(jointHandle,180*math.pi/180) -- set the position to 180 degrees
sim.switchThread() -- the thread resumes in next simulation step
sim.setJointPosition(jointHandle,0*math.pi/180) -- set the position to 0 degrees
sim.switchThread() -- the thread resumes in next simulation step
-- etc.
sim.setThreadAutomaticSwitch(initialForbidLevel) -- Restore the automatic thread switching

-- In above code, a new joint position is applied in each simulation step
</code>

<p>When controlling a joint that is kinematic mode from an external application (e.g. via the <a href="remoteApiOverview.htm">remote API</a> or <a href="rosInterfaces.htm">ROS</a>), then the external controller will run asynchronously to CoppeliaSim (i.e. similar to the non-synchronized code of a threaded <a href="childScripts.htm">child script</a>). This is fine most of the time for <strong><em>loose</em></strong> control, but for <em><strong>precise</strong></em> control (in each simulation loop), CoppeliaSim should run in stepped mode, and the external controller (e.g. the remote API client) will have to trigger each simulation step explicitely. </p>
<p>Following illustrates a Python <a href="zmqRemoteApiOverview.htm">ZeroMQ remote API</a> client that does this:</p>

<code class="hljs language-python coppelia-zmq-remote-api-client">
client.setstepping(True) # enable the stepped mode.
sim.startSimulation() # start the simulation
sim.setJointPosition(jointHandle,90*3.1415/180) # set the joint to 90 degrees
client.step() # trigger next simulation step. Above commands will be applied
sim.setJointPosition(jointHandle,180*3.1415/180) # set the joint to 180 degrees
client.step() # next simulation step executes. Above commands will be applied
sim.setJointPosition(jointHandle,0) # set the joint to 0 degrees
</code>

<p><strong><a name="forceTorqueMode"></a><a name="dynamic"></a>The joint is in dynamic mode</strong>: in this situation, and if additionally the joint is <a href="designingDynamicSimulations.htm#dynamicallyEnabledJoints">dynamically enabled</a>, then it will be indirectly handled by the physics engine. If the joint's motor is not enabled, then it is free or passive. Otherwise, the joint can operate in following two manners:</p>

<li><a href="#controlLoopDisabled">The joint's motor is enabled, but the control loop is disabled</a>. This is used when wanting  to <strong><em>precisely</em></strong> custom control a joint from an external application (e.g. force/torque control, PID, etc.). This method is also used, when wanting to <em><strong>loosely</strong></em>  control a joint in force/torque, or for velocity control (e.g. robot wheel motors).</li>
<li><a href="#controlLoopEnabled">The joint's motor is enabled, and the control loop is enabled</a>. This is used when the joint needs to act as a spring/damper, or when wanting to <strong><em>precisely</em></strong> custom control the joint from within CoppeliaSim, or when wanting to <em><strong>loosely</strong></em>  control a joint in position control from an external application.</li>

<p><a name="controlLoopDisabled"></a>If the <strong>joint motor is enabled, but the control loop is disabled</strong>, then the physics engine will apply the specified <strong>Maximum force/torque</strong>, and accelerate the joint until the <strong>target velocity</strong> is reached. If the load is small and/or the maximum force/torque high, that target velocity will be reached quickly. Otherwise, it will take some time, or, if the force/torque is not large enough, the target velocity will never be reached. The target velocity can programmatically be adjusted with <a href="regularApi/simSetJointTargetVelocity.htm">sim.setJointTargetVelocity</a>, and the maximum force/torque with <a href="regularApi/simSetJointTargetForce.htm">sim.setJointTargetForce</a>. When writing a <strong><em>precise</em></strong> joint controller for a joint in dynamic mode from a <a href="childScripts.htm">child script</a>, beware of following:</p>

<p>By default, the simulation loop runs with a time step of 50ms (in simulation time). But the physics engine will run with a time step of 5ms, i.e. 10 times more often. A child script will be called in each simulation step, but not in each physics engine calculation step. This means that if a joint is controlled from a child script in a <em>regular way</em>, the control algorithm will only be able to provide new control values once for 10 physics engine calculation steps: 9 out of 10 steps will be missed. One way to overcome this would be to change the default <a href="simulationPropertiesDialog.htm">simulation settings</a> and to specify a simulation <strong>time step</strong> of 5ms, instead of 50ms. This works fine, one should remember that all other calculations (e.g. <a href="visionSensors.htm">vision sensors</a>, <a href="proximitySensors.htm">proximity sensors</a>, <a href="distanceCalculation.htm">distance calculations</a>, <a href="kinematics.htm">IK</a>, etc.) will also run 10 times more often, and finally slow down your simulation. Another, much better option, would be to use a <a href="jointCallbackFunctions.htm">joint callback function</a> (or a <a href="dynCallbackFunctions.htm">dynamics callback function</a>) as will be explained further down.</p>

<p>If, one the other hand, one wants to run a <em><strong>precise</strong></em> and regular joint controller externally (e.g. from a <a href="remoteApiOverview.htm">remote API</a> client or a <a href="rosInterfaces.htm">ROS</a> node), then there is no other option than to set the simulation loop to the same rate as the physics engine rate, then run CoppeliaSim in stepped mode, and the external controller (e.g. the remote API client) will have to trigger each simulation step explicitely. </p>

<p>Following illustrates a Python <a href="zmqRemoteApiOverview.htm">ZeroMQ remote API</a> client that does this:</p>

<code class="hljs language-python coppelia-zmq-remote-api-client">
client.setstepping(True)
sim.startSimulation()
sim.setJointTargetForce(jointHandle,1.0,false)
sim.setJointTargetVelocity(jointHandle,180*3.1415/180)
client.step()
sim.setJointTargetForce(jointHandle,0.5,false)
sim.setJointTargetVelocity(jointHandle,180*3.1415/180)
client.step()
sim.setJointTargetForce(jointHandle,2.0,false)
sim.setJointTargetVelocity(jointHandle,180*3.1415/180) # set the joint target velocity
</code>

<p><a name="controlLoopEnabled"></a>If the <strong>joint motor is enabled, and the control loop is also enabled</strong>, then the physics engine will handle the joint according to the setting: the joint can operate in position control (i.e. PID control), in a spring/damper mode, or in custom control. PID and spring/damper parameters can be updated from a <a href="childScripts.htm">child script</a>, from a <a href="remoteApiOverview.htm">remote API</a> client or from a <a href="rosInterfaces.htm">ROS</a> node. Refer to <a href="objectParameterIDs.htm">object parameter IDs</a> sim.jointfloatparam_pid_p, sim.jointfloatparam_pid_i, sim.jointfloatparam_pid_d, and sim.jointfloatparam_kc_k and sim.jointfloatparam_kc_c. Desired target positions can be set with <a href="regularApi/simSetJointTargetPosition.htm">sim.setJointTargetPosition</a>. When in need for a <em><strong>precise</strong></em> custom controller, then a <a href="jointCallbackFunctions.htm">joint callback function</a> should be used instead.</p>

<p>Finally, when in need of a precise PID or custom controller that is implemented in an external application, one needs to make sure that the simulation step is the same as the physics engine calculation step: by default, CoppeliaSim's simulation loop runs at 20Hz (in simulation time), while the physics engine runs at 200Hz. The simulation step size can be adjusted in the <a href="simulationPropertiesDialog.htm">simulation setting</a>. And CoppeliaSim should run in stepped mode. </p>
<p>Following illustrates a Python <a href="zmqRemoteApiOverview.htm">ZeroMQ remote API</a> client that does this:</p>

<code class="hljs language-python coppelia-zmq-remote-api-client">
client.setstepping(True)
sim.startSimulation()
sim.setJointTargetPosition(jointHandle,90*3.1415/180)
client.step()
sim.setJointTargetPosition(jointHandle,180*3.1415/180)
client.step()
sim.setJointTargetPosition(jointHandle,0)
</code>

<p>One can also have a remote API client provide control values for a custom joint controller implemented in a joint callback function, by providing values, for instance via signals, to that joint callback function. For example, from a Python <a href="zmqRemoteApiOverview.htm">ZeroMQ remote API</a> client:</p>

<code class="hljs language-python coppelia-zmq-remote-api-client">
client.setstepping(True)
sim.startSimulation()
sim.setFloatSignal("myDesiredTorque",1.0)
sim.setFloatSignal("myDesiredTarget",90.0*3.1415/180.0)
client.step()
</code>

<p>In above example, the joint callback function could fetch those two signals (with <a href="regularApi/simGetFloatSignal.htm">sim.getFloatSignal</a>) before doing the control.</p>


<br>
<br>

 </tr>
</table> 
</div>  
  
  
</body>

</html>
